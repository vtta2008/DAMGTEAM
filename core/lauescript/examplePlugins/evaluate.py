"""
Created on 09.05.2013

@author: Jens Luebben

Plugin for all sorts of evaluation functions to analyse
the data generated by the APD-Toolkit.
"""

import numpy as np
from numpy.linalg import norm, LinAlgError

import lauescript.cryst.crystgeom as cg
from lauescript.laueio.loader import Loader
from lauescript.cryst.filter import filter_atom_pair


KEY = 'E'
OPTION_ARGUMENTS = {'atomfilter': None,
                    'partnerfilter': None,
                    'file': None,
                    'iso': None,
                    'compare': None,
                    'compare2': None}

data = None


def compare_all(mode='neut'):
    """
    Needs an instance of 'all_data' from the 'classes' module as an
    argument. The second argument defines which method for comparison
    should be used.
    The function compares all calculated ADP of the experimental data
    with its measured counterparts using the specified method. The
    output is written to the file 'evaluate.out'.
    """
    c2 = config.arg('compare2')
    if c2:
        use1 = c2
    else:
        use1 = 'cart_sum'
    method = ws06
    vals = []
    # printer('Comparing measured and calculated\nADP via ' +
    #         'method ws06:\n\nAtom    Difference')
    use = 'cart_neut'
    if mode is not 'neut':
        load(mode)
        use = 'compare'
    for molecule in data:
        if not data[molecule].daba:
            hlist = []
            nlist = []
            atomnames = sorted([atom.name for atom in data[molecule].atoms])
            # for atom in data[molecule].atoms:
            for atomname in atomnames:
                atom = data[molecule][atomname]
                if not atom.name[0] == 'X':
                    # if atom.name == 'H10' or atom.name == 'H11':
                        # print
                    #print atom,np.linalg.det(get_matrix(atom.adp['cart_ext']))
                        # print get_matrix(atom.adp['cart_ext'])
                        # print np.linalg.det(get_matrix(atom.adp['cart_ext']))
                    try:
                        vals.append(method(atom.adp[use1], atom.adp[use]))
                        #pass
                    except LinAlgError:
                        vals.append(999)
                    size = sum(atom.adp[use1][:3]) - sum(atom.adp[use][:3])
                    if size > 0:
                        relSize = '+'
                    elif size == 0:
                        relSize = '='
                    else:
                        relSize = '-'
                    printer('{:7s}{:10f}      {}'.format(atom.name, vals[-1], relSize))
                    if atom.element == 'H':
                        hlist.append(vals[-1])
                    else:
                        nlist.append(vals[-1])

            printer('\nAverage difference:               {:5.3f}'.format(sum(vals) / len(vals)))
            printer('\nAverage heavy atom difference:    {:5.3f}'.format(sum(nlist) / len(nlist)))
            hav = sum(hlist) / len(hlist)
            std = np.std(hlist) * 3
            nh = []
            for h in hlist:
                if not h - hav > std:
                    nh.append(h)
            nhav = sum(nh) / len(nh)
            printer('Average hydrogen atom difference: {:5.3f}'.format(hav))
            printer('Average difference ( < 3 sigma ): {:5.3f}'.format(nhav))


def load(filename):
    loader = Loader(config.get_active_printer())
    loader.create(filename)
    mol = loader.load('compare')
    printer('Using file {} for comparison.'.format(filename))
    for atom in data['exp'].atoms:
        try:
            atom.adp['compare'] = mol[atom.name].adp['cart_meas']
        except KeyError:
            atom.adp['compare'] = [1, 1, 1, 0, 0, 0]


def c1(adp1, adp2):
    """
    Compare method 1

    Compares two sets of ADP by calculating the sum of the differences
    of the lenghts of the ADP's principle axis multiplied by the cosine
    of the angle between the axis. The smaller the value the more
    similarity between the two sets of ADP.
    Needs two sets of APD in XD format as arguments and returns the
    comparison value. The smaller the value the more similar are the two
    sets of ADP.
    :param adp1: List/Array type of length 6.
    :param adp2: List/Array type of length 6.
    :returns: Float representing similarity of adp1 and adp2.
    """

    def get_axis(adp):
        """
        Returns ADP as its three principle axis representation.
        :param adp: List/Array type of length 6.
        :returns: List of three arrays of length 3.
        """
        adp = np.matrix([[float(adp[0]), float(adp[3]), float(adp[4])],
                         [float(adp[3]), float(adp[1]), float(adp[5])],
                         [float(adp[4]), float(adp[5]), float(adp[2])]])
        w, v = np.linalg.eig(adp)
        return [np.array((w[j] * v[:, j]).flatten().tolist()[0]) for j \
                in range(3)]

    adp1_axis = get_axis(adp1)
    adp2_axis = get_axis(adp2)

    val = 0
    for i in range(3):
        addval = abs(norm(adp1_axis[i] - adp2_axis[i]))
        addval = addval * abs((1 - abs(np.dot(adp1_axis[i], adp2_axis[i]))))
        val += addval
    return val


def get_matrix(adp):
    """
    Transforms an ADP to its matrix representation.
    :param adp: List/Array type of length 6.
    :return: 3x3 np.matrix
    """
    adp = np.matrix([[float(adp[0]), float(adp[3]), float(adp[4])],
                    [float(adp[3]), float(adp[1]), float(adp[5])],
                    [float(adp[4]), float(adp[5]), float(adp[2])]])
    return adp


def ws06(adp1, adp2):
    """
    Compare method as introduced by Whitten & Spackman 2006

    The function calculates the overlap 'R' of two ADP's ellipsoid
    representations. The functions returns the similarity index 'S'
    which is given by 'S=100(1-R)'.
    :param adp1: List/Array type of length 6.
    :param adp2: List/Array type of length 6.
    :returns: Float representing similarity of adp1 and adp2.
    """
    # print sum(adp1[:3])/3. - sum(adp2[:3])/3.
    adp1 = get_matrix(adp1)
    adp2 = get_matrix(adp2)
    adp1i = np.linalg.inv(adp1)
    adp2i = np.linalg.inv(adp2)
    a = 2 ** 1.5
    b = np.dot(adp1i, adp2i)
    c = np.linalg.det(b)

    # if c <= 0:
    #     c *= -1
    d = c ** 0.25
    up = a * d

    x = adp1i + adp2i
    y = np.linalg.det(x)
    # if y <= 0:
    #     y *= -1
    z = y ** 0.5
    R = up / z
    return 100 * (1 - R)


def ADP_trace(adp):
    """
    Returns the trace of an ADP in XD naming convention.
    :param adp: List/Array type of length 6.
    :returns: Float representing the ADPs Ueq value.
    """
    return sum(adp[:3])


def set_filter():
    """
    Function to define which atom pairs are used for the
    calculation of Uiso.

    The filter a list of lists. Every list is one
    filter critereon consisting of an attribute, a value
    a truth criteron and a function.
    For every list the value of the specified attribute is
    compared to the value specified. Only if the comparison of
    both values is equal to the specified truth criterion,
    the Uiso value is calculated.
    If a function is specified, the attribute is passed to
    the function and the return value is compared to
    the truth criterion.
    The latter three parameters default to 'True', True', None
    if not specified.

    To define the filter the commandline argument 'filter=' is
    used.
    Example:
    '... filter=filter=[invariom_name:O2c,invariom_code:42:True,None]
    will generate:
    [['invariom_name', 'O2c',True,None],
    ['invariom_code', 42 , True, len]]
    This filter defines that only those atoms with the invariom
    name 'O2c' and an invariom code with a length of 42 are considered
    for Uiso calculations.

    A second filter is defined for neighbor atoms. It follows the
    same syntax except its commanline keyword is 'partnerfilter'
    and is applied to all atoms returned by crystgeom.get_framework\
    _neighbors().
    """
    try:
        #=======================================================================
        # isofilter=[arg.partition('=')[-1] for arg in argv if 'atomfilter=' in arg][0][1:-1].split(',')
        #=======================================================================
        isofilter = config.arg('atomfilter')[1:-1].split(',')
        isofilter = [f.split(':') for f in isofilter]
        for f in isofilter:
            if len(f) < 2:
                f.append('True')
            if len(f) < 3:
                f.append('True')
            if len(f) < 4:
                f.append('None')
    except:
        isofilter = [['element', 'H', 'True', 'None']]
    try:
        #=======================================================================
        # isopartnerfilter=[arg.partition('=')[-1] for arg in argv if 'partnerfilter=' in arg][0][1:-1].split(',')
        #=======================================================================
        isopartnerfilter = config.arg('partnerfilter')[1:-1].split(',')
        isopartnerfilter = [f.split(':') for f in isopartnerfilter]
        for f in isopartnerfilter:
            if len(f) < 2:
                f.append('True')
            if len(f) < 3:
                f.append('True')
            if len(f) < 4:
                f.append('None')
    except:
        isopartnerfilter = [['None', 'None', 'None', 'None']]
    return isofilter, isopartnerfilter
    isofilterlist = []
    isopartnerfilterlist = []
    for i in range(len(isofilter) / 2):
        isofilterlist.append(tuple(isofilter[2 * i:2 * i + 2]))
    for i in range(len(isopartnerfilter) / 2):
        isopartnerfilterlist.append(tuple(isopartnerfilter[2 * i:2 * i + 2]))

    return [isofilterlist, isopartnerfilterlist]


def apply_filter(atom, isofilters):
    """
    Evaluates the filter expression. Returns True
    if the the filter value is equal to the
    corresponding attribute for all filters.
    """
    if 'None' in isofilters[0][0]:
        return True

    functionfilters = [isofilter for isofilter in isofilters if not isofilter[-1] == 'None']
    functionfilters = ['{}(atom.{}){}={}'.format(f[3], f[0], f[2], f[1]).replace('True', '=').replace('False', '!') for
                       f in functionfilters]

    if all(getattr(atom, isofilter[0]) == isofilter[1] for isofilter in isofilters if
           isofilter[2] == 'True' and isofilter[-1] == 'None'):
        if all(getattr(atom, isofilter[0]) != isofilter[1] for isofilter in isofilters if
               isofilter[2] == 'False' and isofilter[-1] == 'None'):
            for functionfilter in functionfilters:
                if not eval(functionfilter):
                    return False
            return True
    else:
        return False


def Uiso(data, logfile):
    """
    Method for calculating the size of U_iso hydrogen ADP
    relative the the U_iso ADP of the bonding partner.
    """
    printer.register_file(logfile, 'log', mode='a')
    # isofilters, isopartnerfilters = set_filter()
    #===========================================================================
    # keys=['cart_int','cart_ext','cart_sum','cart_meas','iso_meas']
    #===========================================================================
    use1, use2 = None, None
    try:
        use = config.arg('iso').split(':')
        use1 = use[0]
        use2 = use[1]

    except:
        use1 = 'cart_sum'
        use2 = 'cart_sum'
    # printer('\nSelected filters:\n\n  Attribute      |    Value     | True  | Function'
    #         '\n===================================================\nAtom filter:     |              |       |')
    # for isofilter in isofilters:
    #     printer('{:15s}  | {:12s} | {:5s} | {}'.format(isofilter[0], isofilter[1], isofilter[2], isofilter[3]))
    # printer('-----------------|--------------|-------|----------\nPartner filter:  |              |       |')
    # for isofilter in isopartnerfilters:
    #     printer('{:15s}  | {:12s} | {:5s} | {}'.format(isofilter[0], isofilter[1], isofilter[2], isofilter[3]))
    printer('\nComparing {} of hydrogen atoms\nwith {} of parent atoms.\n'.format(use1, use2))
    printer(' Riding | Parent | U_rel | U_rel\n  atom  |  atom  | geom  | arith')
    printer(' ================================')
    geom_sum = []
    arit_sum = []
    for atom in data['exp'].atoms:
        # if apply_filter(atom, isofilters):
            for heavy_atom in cg.get_framework_neighbours(atom, useH=True):
                if not atom == heavy_atom and filter_atom_pair(config, atom, heavy_atom):
                    U_rel_geom = cg.Uiso(atom.adp[use1]) / cg.Uiso(heavy_atom.adp[use2])
                    geom_sum.append(U_rel_geom)
                    U_rel_arith = cg.Uiso(atom.adp[use1], mean='arithmetic') / \
                                  cg.Uiso(heavy_atom.adp[use2], mean='arithmetic')
                    arit_sum.append(U_rel_arith)
                    printer('  {light:5s} |  {heavy:5s} | {U:5.3f} | {U2:5.3f}'.format(light=atom.name,
                                                                                       heavy=heavy_atom,
                                                                                       U=U_rel_geom,
                                                                                       U2=U_rel_arith))
    printer(' -------|--------|-------|-------')
    printer('  {light:5s} |  {heavy:5s} | {U:5.3f} | {U2:5.3f}'.format(light='mean',
                                                                       heavy='---',
                                                                       U=np.mean(geom_sum),
                                                                       U2=np.mean(arit_sum)))
    printer('  {light:5s} |  {heavy:5s} | {U:5.3f} | {U2:5.3f}'.format(light='SD',
                                                                       heavy='---',
                                                                       U=np.std(geom_sum),
                                                                       U2=np.std(arit_sum)))

    printer('{temp:.1f} {U:5.3f} {Uer:5.3f} {U2:5.3f} {U2er:5.3f}'.format(temp=data.temperature,
                                                                          U=np.mean(geom_sum),
                                                                          Uer=np.std(geom_sum),
                                                                          U2=np.mean(arit_sum),
                                                                          U2er=np.std(arit_sum)),
            use=['log'])
    printer.spacer()


def R_adp(data):
    """
    Prints a table the the R-Values of the TLS-Fit for every atom.
    """
    printer('S_adp = ?')
    printer('R_adp = | (U_iso_xxx - U_iso_obs) / U_iso_obs |')
    printer('mean  = sum((U_iso_xxx - U_iso_obs) / U_iso_obs) / n')
    printer('abs   = sum(R_adp) / n\n')
    printer('(geometric mean is used)\n')

    printer('       | ADP_calc / ADP_obs |  APD_tls / ADP_obs')
    printer('       |--------------------|-------------------')
    printer(' Atom  |   S_adp  |  R_adp  |   S_adp  |  R_adp')
    printer(' ===============================================')
    S_sum = []
    R_sum = []
    S_sum_tls = []
    R_sum_tls = []
    for atom in data['exp'].atoms:
        if not atom.element == 'H':
            U_rel_calc = cg.Uiso(atom.adp['cart_sum'])
            U_rel_obs = cg.Uiso(atom.adp['cart_meas'])
            R_adp = (U_rel_calc - U_rel_obs) / U_rel_obs
            R_sum.append(R_adp)
            S_adp = ws06(atom.adp['cart_sum'], atom.adp['cart_meas'])
            S_sum.append(S_adp)

            U_rel_tls = cg.Uiso(atom.adp['cart_ext'])
            R_tls = (U_rel_tls - U_rel_obs) / U_rel_obs
            R_sum_tls.append(R_tls)

            S_tls = ws06(atom.adp['cart_ext'], atom.adp['cart_meas'])
            S_sum_tls.append(S_tls)

            printer('  {0:5s}|   {1:4.2f}   |  {2:4.2f}   |   {3:4.2f}   |  {4:4.2f}'.format(atom.name,
                                                                                             S_adp,
                                                                                             abs(R_adp),
                                                                                             S_tls,
                                                                                             abs(R_tls)))

    printer(' ------|----------|---------|----------|--------')
    printer('  {0:5s}|   {1:4.2f}   |  {2:4.2f}   |   {3:4.2f}   |  {4:4.2f}'.format('mean',
                                                                                     np.mean(S_sum),
                                                                                     np.mean(R_sum),
                                                                                     np.mean(S_sum_tls),
                                                                                     np.mean(R_sum_tls)))
    printer('  {0:5s}|   {1:4.2f}   |  {2:4.2f}   |   {3:4.2f}   |  {4:4.2f}'.format('abs',
                                                                                     np.mean(S_sum),
                                                                                     np.mean([abs(i) for i in R_sum]),
                                                                                     np.mean(S_sum_tls),
                                                                                     np.mean(
                                                                                         [abs(i) for i in R_sum_tls])))
    printer('  {0:5s}|   {1:4.2f}   |  {2:4.2f}   |   {3:4.2f}   |  {4:4.2f}'.format('SD',
                                                                                     np.std(S_sum),
                                                                                     np.std(R_sum),
                                                                                     np.std(S_sum_tls),
                                                                                     np.std(R_sum_tls)))
    if config.arg('correlate'):
        printer('\n\'mean R_adp (ADP_calc / ADP_obs)\' can be\ninterpreted as the ratio 1 - (ADP_int / ADP_obs).')
    else:
        printer('\n\'mean R_adp (ADP_tls / ADP_obs)\' can be\ninterpreted as the ratio 1 - (ADP_obs / ADP_int).')


def overview(data):
    """
    Prints an overview table listing atom names, invariom names, and model compounds.
    """

    printer.table(['Name', 'El', 'Invariom name', 'Model compound'], head=True)
    for atom in data.iter_atoms(True):
        printer.table([atom.name, atom.element, atom.invariom_name, atom.invariom.molecule.name])
    printer.table(done=True)


def run(configurator, **kwargs):
    """
    Called by the plugin manager.
    Asks the plugin manager for user input and calls the
    corresponding functions.
    """
    global printer, config
    config = configurator
    printer = config.setup()

    logfile = config.arg('file')
    if not logfile:
        logfile = 'apd_Uiso.out'
    global data
    data = config.get_variable()
    if config.arg('iso'):
        printer('\nEvaluating U_rel.\n')
        Uiso(data, logfile)
    if config.arg('neut'):
        compare_all()
    compare = config.arg('compare')
    if compare:
        compare_all(compare)
    if config.arg('resi'):
        printer('\nEvaluating residual ADPs.\n')
        R_adp(data)
    if config.arg('list'):
        printer('\nPrinting structure overview.\n')
        overview(data)

    return 0





